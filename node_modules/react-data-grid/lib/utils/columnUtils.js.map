{"version":3,"file":"columnUtils.js","sourceRoot":"","sources":["../../src/utils/columnUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Column, CalculatedColumn, FormatterProps, Omit } from '../common/types';\nimport { getScrollbarSize } from './domUtils';\n\ninterface Metrics<R, SR> {\n  columns: readonly Column<R, SR>[];\n  columnWidths: ReadonlyMap<string, number>;\n  minColumnWidth: number;\n  viewportWidth: number;\n  defaultFormatter: React.ComponentType<FormatterProps<R, SR>>;\n}\n\ninterface ColumnMetrics<TRow, TSummaryRow> {\n  columns: readonly CalculatedColumn<TRow, TSummaryRow>[];\n  lastFrozenColumnIndex: number;\n  totalColumnWidth: number;\n}\n\nexport function getColumnMetrics<R, SR>(metrics: Metrics<R, SR>): ColumnMetrics<R, SR> {\n  let left = 0;\n  let totalWidth = 0;\n  let allocatedWidths = 0;\n  let unassignedColumnsCount = 0;\n  let lastFrozenColumnIndex = -1;\n  const columns: Array<Omit<Column<R, SR>, 'width'> & { width: number | undefined }> = [];\n\n  for (const metricsColumn of metrics.columns) {\n    let width = getSpecifiedWidth(metricsColumn, metrics.columnWidths, metrics.viewportWidth);\n\n    if (width === undefined) {\n      unassignedColumnsCount++;\n    } else {\n      width = clampColumnWidth(width, metricsColumn, metrics.minColumnWidth);\n      allocatedWidths += width;\n    }\n\n    const column = { ...metricsColumn, width };\n\n    if (column.frozen) {\n      lastFrozenColumnIndex++;\n      columns.splice(lastFrozenColumnIndex, 0, column);\n    } else {\n      columns.push(column);\n    }\n  }\n\n  const unallocatedWidth = metrics.viewportWidth - allocatedWidths - getScrollbarSize();\n  const unallocatedColumnWidth = Math.max(\n    Math.floor(unallocatedWidth / unassignedColumnsCount),\n    metrics.minColumnWidth\n  );\n\n  const calculatedColumns: CalculatedColumn<R, SR>[] = columns.map((column, idx) => {\n    // Every column should have a valid width as this stage\n    const width = column.width ?? clampColumnWidth(unallocatedColumnWidth, column, metrics.minColumnWidth);\n    const newColumn = {\n      ...column,\n      idx,\n      width,\n      left,\n      formatter: column.formatter ?? metrics.defaultFormatter\n    };\n    totalWidth += width;\n    left += width;\n    return newColumn;\n  });\n\n  return {\n    columns: calculatedColumns,\n    lastFrozenColumnIndex,\n    totalColumnWidth: totalWidth\n  };\n}\n\nfunction getSpecifiedWidth<R, SR>(\n  { key, width }: Column<R, SR>,\n  columnWidths: ReadonlyMap<string, number>,\n  viewportWidth: number\n): number | undefined {\n  if (columnWidths.has(key)) {\n    // Use the resized width if available\n    return columnWidths.get(key);\n  }\n  if (typeof width === 'number') {\n    return width;\n  }\n  if (typeof width === 'string' && /^\\d+%$/.test(width)) {\n    return Math.floor(viewportWidth * parseInt(width, 10) / 100);\n  }\n  return undefined;\n}\n\nfunction clampColumnWidth<R, SR>(\n  width: number,\n  { minWidth, maxWidth }: Column<R, SR>,\n  minColumnWidth: number\n): number {\n  width = Math.max(width, minWidth ?? minColumnWidth);\n\n  if (typeof maxWidth === 'number') {\n    return Math.min(width, maxWidth);\n  }\n\n  return width;\n}\n\n// Logic extented to allow for functions to be passed down in column.editable\n// this allows us to decide whether we can be editing from a cell level\nexport function canEdit<R, SR>(column: CalculatedColumn<R, SR>, row: R): boolean {\n  if (typeof column.editable === 'function') {\n    return column.editable(row);\n  }\n  return Boolean(column.editor || column.editable);\n}\n\nexport function getColumnScrollPosition<R, SR>(columns: readonly CalculatedColumn<R, SR>[], idx: number, currentScrollLeft: number, currentClientWidth: number): number {\n  let left = 0;\n  let frozen = 0;\n\n  for (let i = 0; i < idx; i++) {\n    const column = columns[i];\n    if (column) {\n      if (column.width) {\n        left += column.width;\n      }\n      if (column.frozen) {\n        frozen += column.width;\n      }\n    }\n  }\n\n  const selectedColumn = columns[idx];\n  if (selectedColumn) {\n    const scrollLeft = left - frozen - currentScrollLeft;\n    const scrollRight = left + selectedColumn.width - currentScrollLeft;\n\n    if (scrollLeft < 0) {\n      return scrollLeft;\n    }\n    if (scrollRight > currentClientWidth) {\n      return scrollRight - currentClientWidth;\n    }\n  }\n\n  return 0;\n}\n"]}